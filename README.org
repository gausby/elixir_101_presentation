#+TITLE: Elixir 101
#+AUTHOR: Martin Gausby

* Elixir


** Some definitions
*** Erlang
*** Elixir
*** Beam
*** OTP
*** Processes

** How Elixir relates to Erlang, OTP, and Beam

** Where Elixir differs from what you are used to

*** Pattern Matching
You might be used to variables where you can bind a value. For instance, if we bind ~a~ to ~5~ like so in JavaScript

#+BEGIN_SRC javascript
// in JavaScript
var a = 5
#+END_SRC

~a~ will be ~5~ from then on. This would be the same in Elixir, but we would not have to declare that we are creating a variable or define what type it has:

#+BEGIN_SRC elixir
# in elixir
a = 5
#+END_SRC

But where the Elixir ~=~ operator differentiate itself from the JavaScript one is in the fact that it is a match operator rather than an assignment operator. ~=~ will match the left-hand side with the right-hand side and assert values if they fit; if they do not an exception will get raised.

#+BEGIN_SRC elixir
{a, b, c} = {:symbol, "hello", 42}
#+END_SRC

In this case ~a~, ~b~, and ~c~ will get the values, respectively, ~:symbol~, ~"hello"~, and ~42~.

A common pattern in Elixir (and Erlang) is to return a tuple with the symbol ~:error~ and a string containing the reason for the error, or a tuple containing ~:ok~ and the value from the operation. This can be used to handle error and success cases in an elegant fashion.

#+BEGIN_SRC elixir
case File.read("/etc/hosts") do
  {:ok, content} ->
    do_stuff_with(content)
  {:error, reason} ->
    Mix.raise("Could not read hosts file because of: #{reason}")
end
#+END_SRC

*** Modules

*** State

*** Immutable data

**** What are the benefits of immutable data?

*** Processes
**** The Actor Model
**** Isolation, shared nothing
**** Isolated failures

** Fault Tolerance

** Tooling
*** Mix
*** Editor support

** Documentation as a first-class citizen

** How to communicate OTP
*** Trees for supervision
*** Message sequence charts for inter process communication

** Resources for learning Elixir
*** The getting started guides on elixirlang.org
**** introduction to the language itself
**** there's also a great OTP and Mix introduction
**** even a macro guide

*** Books
If you are only going to buy two Elixir books I would recommend:

**** Programming Elixir by Dave Thomas
Does an excellent job of teaching pattern matching and recursive functions and thinking, but it does not go into great detail of processes, supervision, OTP, and the like.

**** Elixir in Action by Saša Jurić
If you have read Programming Elixir by Dave Thomas you should pick up Jurić's book and skip the first part. This one does a great job of explaining OTP. Not only does it tell you how, but it also gives an answer to they whys.

*** IRC
**** #cphex on freenode
**** #elixir-lang on freenode

*** Copenhagen Elixir and Erlang
We organize meet ups and events using GitHub issues. If you want to learn how to do something in Elixir you could suggest an event and we will help each other find a suitable venue, create learning material, and communicate the event to the public.
