#+TITLE: Elixir 101
#+AUTHOR: Martin Gausby

* Elixir


** Some definitions
*** Erlang
*** Elixir
*** Beam
*** OTP
*** Processes

** How Elixir relates to Erlang, OTP, and Beam

** Where Elixir differs from what you are used to

*** Pattern Matching
You might be used to variables where you can bind a value. For instance, if we bind ~a~ to ~5~ like so in JavaScript

#+BEGIN_SRC javascript
// in JavaScript
var a = 5
#+END_SRC

~a~ will be ~5~ from then on. This would be the same in Elixir, but we would not have to declare that we are creating a variable or define what type it has:

#+BEGIN_SRC elixir
# in elixir
a = 5
#+END_SRC

But where the Elixir ~=~ operator differentiate itself from the JavaScript one is in the fact that it is a match operator rather than an assignment operator. ~=~ will match the left-hand side with the right-hand side and assert values if they fit; if they do not an exception will get raised.

#+BEGIN_SRC elixir
{a, b, c} = {:symbol, "hello", 42}
#+END_SRC

In this case ~a~, ~b~, and ~c~ will get the values, respectively, ~:symbol~, ~"hello"~, and ~42~.

A common pattern in Elixir (and Erlang) is to return a tuple with the symbol ~:error~ and a string containing the reason for the error, or a tuple containing ~:ok~ and the value from the operation. This can be used to handle error and success cases in an elegant fashion.

#+BEGIN_SRC elixir
case File.read("/etc/hosts") do
  {:ok, content} ->
    do_stuff_with(content)
  {:error, reason} ->
    Mix.raise("Could not read hosts file because of: #{reason}")
end
#+END_SRC

*** Modules and functions
Functions in Elixir are, like any other good functional language, data, and can be assigned to variables; passed into functions as arguments; and returned from functions.

#+BEGIN_SRC elixir
square = fn x ->
  x * x
end
#+END_SRC

An anonymous function that takes one argument are now bound to the variable ~square~. To execute an anonymous function we need to write this incarnation:

#+BEGIN_SRC elixir
square.(10)
#+END_SRC

Which of course returns ~100~.

A thing to notice here: In most languages we would have to write a ~return~-keyword to have the function return something. We do not need to do that in Elixir; the last evaluated statement in the function body is the return value. This might take some time getting used to, but just returning the value of the last expression is really neat; a function will never return something in the middle of the body, and it removes some syntactic noise.

Speaking of removing syntactic noise: Notice that there was no parentheses around the function argument. They could have been there; they are optional—except for the cases where they are required to solve ambiguity.

We can do named functions as well, but they need to be inside a module. A module can be defined with ~defmodule~ like so, and inside that we can use ~def~ and ~defp~ to create public and private functions:

#+BEGIN_SRC elixir
defmodule Math do
  def square x do
    x * x
  end
end
#+END_SRC

We can now get 10 squared by writing ~Math.square 10~.

Notice that module names are written in CamelCase, and function names within are written in snake_case (like ~my_function_name~).

Functions in Elixir are defined by their name and their arity; this means we can have multiple functions with the name name that accept different numbers of arguments, and that is why a given function name in the documentation is referred to with a trailing slash and a number—the name and the number of arguments—like ~Enum.reduce/2~, ~Enum.reduce/3~, etc.

**** Pattern Matching and Functions
The stuff we learned about pattern matching in the pattern matching section works for function argument lists as well. We can assert expected data and the first function that match will get run.

#+BEGIN_SRC elixir
defmodule Validator do
  def handle_result({:invalid, issues}) do
    # create a report from the data stored in issues
  end
  def handle_result({:valid, _}) do
    # write a success message
  end
end
#+END_SRC

Notice, when we use the underscore as a variable name that match is ignored. This is important, because sometimes we are simply not interested in the value contained in the field, and we do not want to get an unused assignment error from the compiler.

**** Guard Clauses
Sometimes pattern matching is not enough, for instance we cannot express that we want a list with more than, or less than, a specified number of elements. To solve this problem we can use guard clauses specified with the keyword ~with~:

#+BEGIN_SRC elixir
defmodule MyList do
  def long_list?(list) when length(list) > 10 do
    true
  end
  def long_list?(list) do
    false
  end
end
#+END_SRC

Not all expressions are allowed in guards clauses; only basic logic and checks. See the documentation for the full list.
*** Immutable data

**** What are the benefits of immutable data?

*** Polymorphism
*** State
*** Processes
**** The Actor Model
**** Isolation, shared nothing
**** Isolated failures

** Fault Tolerance

** Tooling
*** Mix
*** Editor support

** Documentation as a first-class citizen

** How to communicate OTP
*** Trees for supervision
*** Message sequence charts for inter process communication

** Resources for learning Elixir
*** The getting started guides on elixirlang.org
**** introduction to the language itself
**** there's also a great OTP and Mix introduction
**** even a macro guide

*** Books
If you are only going to buy two Elixir books I would recommend:

**** Programming Elixir by Dave Thomas
Does an excellent job of teaching pattern matching and recursive functions and thinking, but it does not go into great detail of processes, supervision, OTP, and the like.

**** Elixir in Action by Saša Jurić
If you have read Programming Elixir by Dave Thomas you should pick up Jurić's book and skip the first part. This one does a great job of explaining OTP. Not only does it tell you how, but it also gives an answer to they whys.

*** IRC
**** #cphex on freenode
**** #elixir-lang on freenode

*** Copenhagen Elixir and Erlang
We organize meet ups and events using GitHub issues. If you want to learn how to do something in Elixir you could suggest an event and we will help each other find a suitable venue, create learning material, and communicate the event to the public.
