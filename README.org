#+TITLE: Elixir 101
#+AUTHOR: Martin Gausby

* Elixir


** Some definitions
*** Erlang
*** Elixir
*** Beam
*** OTP
*** Processes

** How Elixir relates to Erlang, OTP, and Beam

** Where Elixir differs from what you are used to

*** Pattern Matching
You might be used to variables where you can bind a value. For instance, if we bind ~a~ to ~5~ like so in JavaScript

#+BEGIN_SRC javascript
// in JavaScript
var a = 5
#+END_SRC

~a~ will be ~5~ from then on. This would be the same in Elixir, but we would not have to declare that we are creating a variable or define what type it has:

#+BEGIN_SRC elixir
# in elixir
a = 5
#+END_SRC

But where the Elixir ~=~ operator differentiate itself from the JavaScript one is in the fact that it is a match operator rather than an assignment operator. ~=~ will match the left-hand side with the right-hand side and assert values if they fit; if they do not an exception will get raised.

#+BEGIN_SRC elixir
{a, b, c} = {:symbol, "hello", 42}
#+END_SRC

In this case ~a~, ~b~, and ~c~ will get the values, respectively, ~:symbol~, ~"hello"~, and ~42~.

A common pattern in Elixir (and Erlang) is to return a tuple with the symbol ~:error~ and a string containing the reason for the error, or a tuple containing ~:ok~ and the value from the operation. This can be used to handle error and success cases in an elegant fashion.

#+BEGIN_SRC elixir
case File.read("/etc/hosts") do
  {:ok, content} ->
    do_stuff_with(content)
  {:error, reason} ->
    Mix.raise("Could not read hosts file because of: #{reason}")
end
#+END_SRC

*** Modules and functions
Functions in Elixir are, like any other good functional language, data, and can be assigned to variables; passed into functions as arguments; and returned from functions.

#+BEGIN_SRC elixir
square = fn x ->
  x * x
end
#+END_SRC

An anonymous function that takes one argument are now bound to the variable ~square~. To execute an anonymous function we need to write this incarnation:

#+BEGIN_SRC elixir
square.(10)
#+END_SRC

Which of course returns ~100~.

A thing to notice here: In most languages we would have to write a ~return~-keyword to have the function return something. We do not need to do that in Elixir; the last evaluated statement in the function body is the return value. This might take some time getting used to, but just returning the value of the last expression is really neat; a function will never return something in the middle of the body, and it removes some syntactic noise.

Speaking of removing syntactic noise: Notice that there was no parentheses around the function argument. They could have been there; they are optional—except for the cases where they are required to solve ambiguity.

*** State

*** Immutable data

**** What are the benefits of immutable data?

*** Processes
**** The Actor Model
**** Isolation, shared nothing
**** Isolated failures

** Fault Tolerance

** Tooling
*** Mix
*** Editor support

** Documentation as a first-class citizen

** How to communicate OTP
*** Trees for supervision
*** Message sequence charts for inter process communication

** Resources for learning Elixir
*** The getting started guides on elixirlang.org
**** introduction to the language itself
**** there's also a great OTP and Mix introduction
**** even a macro guide

*** Books
If you are only going to buy two Elixir books I would recommend:

**** Programming Elixir by Dave Thomas
Does an excellent job of teaching pattern matching and recursive functions and thinking, but it does not go into great detail of processes, supervision, OTP, and the like.

**** Elixir in Action by Saša Jurić
If you have read Programming Elixir by Dave Thomas you should pick up Jurić's book and skip the first part. This one does a great job of explaining OTP. Not only does it tell you how, but it also gives an answer to they whys.

*** IRC
**** #cphex on freenode
**** #elixir-lang on freenode

*** Copenhagen Elixir and Erlang
We organize meet ups and events using GitHub issues. If you want to learn how to do something in Elixir you could suggest an event and we will help each other find a suitable venue, create learning material, and communicate the event to the public.
